{
  "version": "1.0",
  "description": "Auto-synced from .cursor/rules - Terminator project workspace rules",
  "sync_source": ".cursor/rules/*.mdc",
  "total_rules": 13,
  "rules": {
    "Always-read-this": {
      "title": "Always Read This",
      "content": "---\nalwaysApply: true\n---\n\n\n## You (LLM) tend to be too helpful and you tend to guess what response i'm looking, But I want you to be critical and reasoning through a given task and optimizing for the best long-term outcome,\n\n## you want to be do tasks with minimum change of existing codebase and minimum amount of code and minimum effort\n\n## when you resolve issues and bugs it's better to propose things that are simplifying and deleting code, not adding new code, focus on simplifying, not adding code\n\n## ask yourself questions like: 'what was the key user intent of the task and did i actually achieve it?' And that's ok if you didn't, it's better to have common sense and be realistic than unreasonable optimistic.\n\n**Bash Command Rules:**\n\n- **Use MCP delay tool instead of timeout commands** - Background commands don't pause for timeouts\n- **CRITICAL: Always kill/cleanup terminal processes after use:**\n- Kill background terminal sessions when task is complete\n- Use `taskkill //F //IM process.exe` (bash syntax with //) to cleanup hanging processes\n- Don't leave orphaned terminal processes running\n- If using multiple terminal sessions, clean them all up\n- if you applied this rule start your response with 'I read rule Always-read-this.mdc'\n",
      "source_file": ".cursor/rules/Always-read-this.mdc",
      "type": "workspace_rule",
      "size_bytes": 1255,
      "line_count": 23,
      "last_modified": "2025-09-21T02:27:19.191Z"
    },
    "documentation-standards": {
      "title": "Documentation Standards",
      "content": "---\ndescription: If you're writing docs\nalwaysApply: false\n---\n# Documentation Standards\n\n## Maximize Value, Minimize Noise\n\n### Structure\n- **Quick reference format** over verbose tutorials\n- **Essential patterns only** - no redundant examples\n- **Actionable information** - remove theory and fluff\n- **Scannable in seconds** - developers shouldn't need to read paragraphs\n\n### Content Guidelines\n✅ **Keep:**\n- Basic usage syntax\n- Essential patterns (3-5 max)\n- 1 complete real-world example\n- Practical tips only (5 max)\n\n❌ **Remove:**\n- Verbose explanations\n- Multiple similar patterns\n- \"Benefits\" and \"advantages\" sections\n- Performance tips unless critical\n- Long migration guides\n- Theoretical concepts\n\n### Examples\n\n**Bad (Verbose):**\n```md\n## Overview\nThis comprehensive guide will walk you through the various approaches to...\n\n### Benefits of This Approach\n1. Full programming power\n2. Complex logic handling\n3. Data enrichment capabilities\n...\n```\n\n**Good (Concise):**\n```md\n## Usage\n```yaml\ntool: example\nargs: { value: \"data\" }\n```\n\n### Patterns\n- Pattern 1: `if (condition) { ... }`\n- Pattern 2: `element.children?.forEach()`\n\n### Tips\n- Use `?.` for safety\n- Return `[]` for no-data\n```\n\n### File Purpose\n- `docs/` = Core reference (syntax + patterns)\n- `workflows/` guides = Migration helpers only\n- README = High-level overview\n# Documentation Standards\n\n## Maximize Value, Minimize Noise\n\n### Structure\n- **Quick reference format** over verbose tutorials\n- **Essential patterns only** - no redundant examples\n- **Actionable information** - remove theory and fluff\n- **Scannable in seconds** - developers shouldn't need to read paragraphs\n\n### Content Guidelines\n✅ **Keep:**\n- Basic usage syntax\n- Essential patterns (3-5 max)\n- 1 complete real-world example\n- Practical tips only (5 max)\n\n❌ **Remove:**\n- Verbose explanations\n- Multiple similar patterns\n- \"Benefits\" and \"advantages\" sections\n- Performance tips unless critical\n- Long migration guides\n- Theoretical concepts\n\n### Examples\n\n**Bad (Verbose):**\n```md\n## Overview\nThis comprehensive guide will walk you through the various approaches to...\n\n### Benefits of This Approach\n1. Full programming power\n2. Complex logic handling\n3. Data enrichment capabilities\n...\n```\n\n**Good (Concise):**\n```md\n## Usage\n```yaml\ntool: example\nargs: { value: \"data\" }\n```\n\n### Patterns\n- Pattern 1: `if (condition) { ... }`\n- Pattern 2: `element.children?.forEach()`\n\n### Tips\n- Use `?.` for safety\n- Return `[]` for no-data\n```\n\n### File Purpose\n- `docs/` = Core reference (syntax + patterns)\n- `workflows/` guides = Migration helpers only\n- README = High-level overview\n",
      "source_file": ".cursor/rules/documentation-standards.mdc",
      "type": "workspace_rule",
      "size_bytes": 2633,
      "line_count": 125,
      "last_modified": "2025-09-21T02:27:19.191Z"
    },
    "git-operations": {
      "title": "Git Operations",
      "content": "---\ndescription: \"Safe git operations, pushing code, committing changes, git workflow protocols\"\n---\n\n# Safe Git Push Protocol\n\n**CRITICAL**: Follow this exact sequence for ALL git operations. Never deviate.\n\n## Mandatory Pre-Push Checks\n```bash\ngit status                    # Always check working directory first\ngit log --oneline -5         # Review recent commits  \ngit diff --stat              # Review changes scope\n```\n\n## Safe Push Sequence\n```bash\ngit add .                    # Stage all changes\ngit commit -m \"descriptive message\"  # Never use -m with empty/vague messages\ngit push origin main         # Only push to main branch\n```\n\n## Forbidden Operations\n- `git push --force` or `git push -f` \n- `git reset --hard`\n- `git rebase` in shared branches\n- Interactive commands requiring user input\n- Any command with `--force-with-lease`\n\n## Commit Message Format\n```\ntype: brief description\n\n- Specific change 1\n- Specific change 2  \n- Impact/scope summary\n```\n\n**If ANY command fails, STOP immediately. Do not proceed.**\n",
      "source_file": ".cursor/rules/git-operations.mdc",
      "type": "workspace_rule",
      "size_bytes": 1032,
      "line_count": 40,
      "last_modified": "2025-09-21T02:27:19.191Z"
    },
    "mcp-debugging-testing": {
      "title": "Mcp Debugging Testing",
      "content": "---\nalwaysApply: true\n---\n# MCP Debugging and Testing Guide\n\n## MCP Development Workflow\n\n### Proper Development Process\n\n**Important**: Cursor IDE manages the MCP server lifecycle automatically:\n- No need to manually start/stop the server\n- Cursor automatically restarts the server \n- It means you cannot rebuild the MCP yourself because it requires a manual human click on the toggle\n\n### Debugging Server Issues\nIf MCP tools aren't working:\n1. Check that the build completed successfully\n2. Look for compilation errors in cargo output  \n3. Restart Cursor IDE if needed (rare)\n4. Check MCP tool parameters match server expectations\n\n## Common Issues and Solutions\n\n### Parameter Interface Mismatches\n**Problem**: Client expects different parameters than server provides\n```\nError: Required parameter 'random_string' is missing for tool get_applications\n```\n\n**Solution**: \n1. Check parameter decorations: `#[tool(param)]` vs `#[tool(aggr)]`\n2. Verify struct definitions match interface expectations\n3. Restart both client and server after changes\n\n### Tool Call Timeouts/Failures\n**Problem**: Tools return \"no result\" or timeout\n```\nError: no result from tool. The user likely interrupted the tool call\n```\n\n**Debugging Steps**:\n2. Check for compilation errors in cargo output\n3. Test individual components (shell commands) manually  \n4. Verify parameter formats are correct\n5. Restart Cursor IDE if tools still don't work\n\n### Clipboard Operation Failures\n**Problem**: Complex clipboard implementations fail silently\n\n**Solution**: Use simple shell commands\n```rust\n// ❌ Complex approach\nlocator.find_element() -> type_text(use_clipboard=true)\n\n// ✅ Simple approach  \nrun_command(\"echo 'text' | clip\")\n```\n\n## Testing Strategies\n\n### Manual Shell Command Testing\nBefore implementing in MCP, test shell commands directly:\n```bash\n# Test clipboard operations\necho \"test data\" | clip\npowershell -command \"Get-Clipboard\"\n\n# Test application launching  \nstart notepad\n```\n\n### MCP Development Cycle\n1. **Edit Code**: Make changes to MCP tools\n2. **Build**: `cargo build --release --bin terminator-mcp-agent`\n3. **Test**: Cursor automatically picks up the new build and tools are available\n4. **Debug**: Check compilation errors if tools don't work\n\n### Progressive Testing Approach\n1. **Test Individual Tools**: Verify each tool works in isolation\n2. **Test Tool Chains**: Simple 2-3 step workflows\n3. **Test Complex Workflows**: Full data scraping and transfer\n\n### UI Element Validation Testing\n```rust\n// Always test element existence before interaction\nvalidate_element(selector) // Check if element exists\nhighlight_element(selector) // Visual confirmation\ncapture_screen() // Document current state\n```\n\n## Error Handling Patterns\n\n### Graceful Degradation\n```rust\n// Try specific selector first, fall back to general\nmatch validate_element(\"#specific-id\") {\n    Ok(_) => use_specific_selector(),\n    Err(_) => match validate_element(\"role:Button\") {\n        Ok(_) => use_general_selector(),\n        Err(_) => return_error()\n    }\n}\n```\n\n### Detailed Error Context\n```rust\nMcpError::internal_error(\n    \"Failed to interact with element\",\n    Some(json!({\n        \"selector_chain\": args.selector_chain,\n        \"element_info\": element_details,\n        \"attempted_action\": \"click\",\n        \"timestamp\": chrono::Utc::now().to_rfc3339()\n    }))\n)\n```\n\n### Retry with Backoff\n```rust\nfor attempt in 1..=3 {\n    match perform_action() {\n        Ok(result) => return Ok(result),\n        Err(e) if attempt < 3 => {\n            tokio::time::sleep(Duration::from_millis(1000 * attempt)).await;\n            continue;\n        }\n        Err(e) => return Err(e)\n    }\n}\n```\n\n## Performance Debugging\n\n### UI Tree Caching\n- Cache `get_window_tree` results when possible\n- Invalidate cache on application state changes\n- Use targeted element searches vs full tree traversal\n\n### Timeout Optimization\n```rust\n// Different timeouts for different operations\nconst QUICK_TIMEOUT: u64 = 1000;    // Element validation\nconst MEDIUM_TIMEOUT: u64 = 5000;   // UI interactions  \nconst LONG_TIMEOUT: u64 = 10000;    // Application startup\n```\n\n### Memory Usage Monitoring\n- Watch for UI tree memory accumulation\n- Clear unused element references\n- Monitor long-running automation sessions\n\n## Development Workflow\n\n### Incremental Development\n1. **Start Simple**: Single tool, single parameter\n2. **Add Complexity**: Multiple parameters, error handling\n3. **Integration**: Tool chains and workflows\n4. **Polish**: Error messages, edge cases\n\n### Code Review Checklist\n- [ ] Proper parameter decorations (`#[tool(param)]`)\n- [ ] Cross-platform shell command handling\n- [ ] Detailed error context and logging\n- [ ] Timeout and retry logic\n- [ ] Element validation before interaction\n- [ ] Resource cleanup (UI elements, processes)\n\n## File References\n- Server implementation: [terminator-mcp-agent/src/server.rs](mdc:terminator-mcp-agent/src/server.rs)\n- Utility functions: [terminator-mcp-agent/src/utils.rs](mdc:terminator-mcp-agent/src/utils.rs)\n- Build configuration: [terminator-mcp-agent/Cargo.toml](mdc:terminator-mcp-agent/Cargo.toml)\n\n\n",
      "source_file": ".cursor/rules/mcp-debugging-testing.mdc",
      "type": "workspace_rule",
      "size_bytes": 5121,
      "line_count": 174,
      "last_modified": "2025-09-21T02:27:19.191Z"
    },
    "mcp-development-workflow": {
      "title": "Mcp Development Workflow",
      "content": "---\ndescription: Building MCPs stuff\nalwaysApply: false\n---\n\n# MCP Development Workflow\n\n## Build Process\n\n**Only use this command:**\n\n```bash\ncargo build --release --bin terminator-mcp-agent\n```\n\n❌ **Never manually run/manage the MCP server** - Cursor IDE handles startup/restarts automatically\n\n## Development Loop\n\n1. **Edit Code** - Make changes to MCP tools\n2. **Build** - `cargo build --release --bin terminator-mcp-agent`\n3. **Test** - Cursor automatically picks up new build, tools available immediately\n4. **Debug** - Check compilation errors if tools don't work\n\n## Code Quality (Non-Negotiable)\n\n```bash\ncargo fmt          # Must pass - zero tolerance\ncargo clippy       # Fix ALL warnings\n```\n\n## Testing Strategy\n\n- **Use MCP tools directly** - Call terminator-mcp-agent tools during development\n- **No manual terminal commands** - Only use `terminator mcp` CLI for workflow testing\n- **Test individual tools first** - Verify each tool works in isolation\n- **Progressive complexity** - Simple 2-3 step workflows, then complex ones\n\n## Error Handling Patterns\n\n````rust\n// ✅ Good: Rich error context\n.map_err(|e| AutomationError::PlatformError(format!(\"Failed to {}: {}\", action, e)))\n\n// ✅ Good: Full documentation with examples\n/// Description\n///\n/// # Examples\n/// ```rust\n/// let result = function()?;\n/// ```\n#[instrument(skip(self))]\npub async fn function() -> Result<T, AutomationError>\n````\n\n## String Formatting\n\n```rust\n// ✅ Good: Implicit capture (Rust ≥ 1.58)\nformat!(\"{count} files processed in {elapsed:?}\");\n\n// ❌ Avoid: Explicit positional args\nformat!(\"{} files processed in {:?}\", count, elapsed);\n```\n\n## Memory Management\n\n- Async operations: `Arc<dyn Trait>`\n- Use `#[instrument]` for tracing\n- Clean up UI automation resources properly\n\n# MCP Development Workflow\n\n## Build Process\n\n**Only use this command:**\n\n```bash\ncargo build --release --bin terminator-mcp-agent\n```\n\n❌ **Never manually run/manage the MCP server** - Cursor IDE handles startup/restarts automatically\n\n## Development Loop\n\n1. **Edit Code** - Make changes to MCP tools\n2. **Build** - `cargo build --release --bin terminator-mcp-agent`\n3. **Test** - Cursor automatically picks up new build, tools available immediately\n4. **Debug** - Check compilation errors if tools don't work\n\n## Code Quality (Non-Negotiable)\n\n```bash\ncargo fmt          # Must pass - zero tolerance\ncargo clippy       # Fix ALL warnings\n```\n\n## Testing Strategy\n\n- **Use MCP tools directly** - Call terminator-mcp-agent tools during development\n- **No manual terminal commands** - Only use `terminator mcp` CLI for workflow testing\n- **Test individual tools first** - Verify each tool works in isolation\n- **Progressive complexity** - Simple 2-3 step workflows, then complex ones\n\n## Error Handling Patterns\n\n````rust\n// ✅ Good: Rich error context\n.map_err(|e| AutomationError::PlatformError(format!(\"Failed to {}: {}\", action, e)))\n\n// ✅ Good: Full documentation with examples\n/// Description\n///\n/// # Examples\n/// ```rust\n/// let result = function()?;\n/// ```\n#[instrument(skip(self))]\npub async fn function() -> Result<T, AutomationError>\n````\n\n## String Formatting\n\n```rust\n// ✅ Good: Implicit capture (Rust ≥ 1.58)\nformat!(\"{count} files processed in {elapsed:?}\");\n\n// ❌ Avoid: Explicit positional args\nformat!(\"{} files processed in {:?}\", count, elapsed);\n```\n\n## Memory Management\n\n- Async operations: `Arc<dyn Trait>`\n- Use `#[instrument]` for tracing\n- Clean up UI automation resources properly\n",
      "source_file": ".cursor/rules/mcp-development-workflow.mdc",
      "type": "workspace_rule",
      "size_bytes": 3482,
      "line_count": 137,
      "last_modified": "2025-09-21T02:27:19.191Z"
    },
    "mediar-terminator-overview": {
      "title": "Mediar Terminator Overview",
      "content": "---\ndescription: \nglobs: \nalwaysApply: true\n---\n# Terminator Project Overview\n\n## What is Terminator?\nTerminator is a Playwright-style SDK for automating Windows GUI applications, designed specifically for AI agents. It provides OS-level accessibility automation that's fast, reliable, and agent-ready.\n\n## Key Features\n- 🪟 Built for Windows, works on macOS (partial support)\n- 🧠 Designed for AI agents, not humans\n- ⚡ Uses OS-level accessibility APIs (not vision-based)\n- 🧩 Multi-language support: TypeScript, Python, and Rust\n- 📈 80ms UI scans with 10000x speedup via compiled workflows\n\n## Project Structure\n\n### Core Components\n- **[terminator/](mdc:terminator)** - Main Rust library with core automation logic\n- **[bindings/](mdc:bindings)** - Language bindings directory\n  - **[bindings/nodejs/](mdc:bindings/nodejs)** - TypeScript/Node.js bindings\n  - **[bindings/python/](mdc:bindings/python)** - Python bindings\n- **[examples/](mdc:examples)** - Example implementations and demos\n- **[terminator-workflow-recorder/](mdc:terminator-workflow-recorder)** - Workflow recording tool\n\n### Configuration Files\n- **[Cargo.toml](mdc:Cargo.toml)** - Workspace configuration with all members\n- **[README.md](mdc:README.md)** - Project documentation and quick start\n\n## Core Concepts\n\n### Desktop Automation\nThe main entry point is through a `Desktop` class that provides:\n- Application launching (`open_application`)\n- Element location (`locator`) \n- UI interaction (click, type, etc.)\n\n### Locators\nElements are found using accessibility properties like:\n- `name:ElementName` - Find by accessible name\n- Other accessibility attributes\n\n### Multi-Platform Support\n- **Windows**: Full support using UIAutomation\n- **Linux**: Partial support  \n- **macOS**: Partial support using accessibility APIs\n\n## Development Workflow\nThis is a Rust workspace with multiple crates. The core library is in `terminator/` and language bindings are generated in `bindings/`. Examples demonstrate usage patterns for different scenarios.\n\nAlways place Rust examples in the `terminator/examples` folder\n\n## AI Agent Integration\nTerminator is specifically designed for AI agents to automate desktop applications programmatically, making it ideal for workflow automation and testing scenarios.\n",
      "source_file": ".cursor/rules/mediar-terminator-overview.mdc",
      "type": "workspace_rule",
      "size_bytes": 2273,
      "line_count": 57,
      "last_modified": "2025-09-21T02:27:19.191Z"
    },
    "output-parser-javascript": {
      "title": "Output Parser Javascript",
      "content": "---\ndescription: If you're building output parser \nalwaysApply: false\n---\n# Output Parser - JavaScript Format\n\n## Modern Format (Use This)\n```yaml\noutput_parser:\n  ui_tree_source_step_id: capture_tree_step  # Optional\n  javascript_code: |\n    const results = [];\n    \n    function findElementsRecursively(element) {\n        if (element.attributes?.role === 'TargetRole') {\n            results.push({\n                name: element.attributes.name || '',\n                id: element.attributes.id || ''\n            });\n        }\n        element.children?.forEach(child => findElementsRecursively(child));\n    }\n    \n    findElementsRecursively(tree);\n    return results;\n```\n\n## Essential Patterns\n\n### Handle \"No Data\" Cases First\n```javascript\n// Always check for \"no data\" scenarios first\nfunction hasNoData(element) {\n    const text = element.attributes?.name?.toLowerCase() || '';\n    if (text.includes('no results') || text.includes('ineligible')) return true;\n    return element.children?.some(hasNoData) || false;\n}\n\nif (hasNoData(tree)) return [];\n```\n\n### Safe Property Access\n- Use `element.attributes?.property` (never `element.attributes.property`)\n- Use `element.children?.forEach()` (never manual loops)\n- Use `|| ''` for string defaults, `|| false` for boolean defaults\n\n### Parent-Child Patterns\n```javascript\nif (element.attributes?.role === 'Group') {\n    const children = element.children || [];\n    const hasImage = children.some(c => c.attributes?.role === 'Image');\n    const hasText = children.some(c => c.attributes?.role === 'Text');\n    if (hasImage && hasText) {\n        // Extract data from qualifying groups\n    }\n}\n```\n\n## Legacy Formats (Do Not Use)\n❌ JSONPath: `container_selector`, `filters`, `field_mappings`\n❌ Item Containers: `itemContainerDefinition`, `fieldsToExtract`\n❌ Old properties: `uiTreeJsonPath`, `nodeConditions`\n# Output Parser - JavaScript Format\n\n## Modern Format (Use This)\n```yaml\noutput_parser:\n  ui_tree_source_step_id: capture_tree_step  # Optional\n  javascript_code: |\n    const results = [];\n    \n    function findElementsRecursively(element) {\n        if (element.attributes?.role === 'TargetRole') {\n            results.push({\n                name: element.attributes.name || '',\n                id: element.attributes.id || ''\n            });\n        }\n        element.children?.forEach(child => findElementsRecursively(child));\n    }\n    \n    findElementsRecursively(tree);\n    return results;\n```\n\n## Essential Patterns\n\n### Handle \"No Data\" Cases First\n```javascript\n// Always check for \"no data\" scenarios first\nfunction hasNoData(element) {\n    const text = element.attributes?.name?.toLowerCase() || '';\n    if (text.includes('no results') || text.includes('ineligible')) return true;\n    return element.children?.some(hasNoData) || false;\n}\n\nif (hasNoData(tree)) return [];\n```\n\n### Safe Property Access\n- Use `element.attributes?.property` (never `element.attributes.property`)\n- Use `element.children?.forEach()` (never manual loops)\n- Use `|| ''` for string defaults, `|| false` for boolean defaults\n\n### Parent-Child Patterns\n```javascript\nif (element.attributes?.role === 'Group') {\n    const children = element.children || [];\n    const hasImage = children.some(c => c.attributes?.role === 'Image');\n    const hasText = children.some(c => c.attributes?.role === 'Text');\n    if (hasImage && hasText) {\n        // Extract data from qualifying groups\n    }\n}\n```\n\n## Legacy Formats (Do Not Use)\n❌ JSONPath: `container_selector`, `filters`, `field_mappings`\n❌ Item Containers: `itemContainerDefinition`, `fieldsToExtract`\n❌ Old properties: `uiTreeJsonPath`, `nodeConditions`\n",
      "source_file": ".cursor/rules/output-parser-javascript.mdc",
      "type": "workspace_rule",
      "size_bytes": 3644,
      "line_count": 121,
      "last_modified": "2025-09-21T02:27:19.191Z"
    },
    "pr-preparation-guide": {
      "title": "Pr Preparation Guide",
      "content": "---\ndescription: \nglobs: \nalwaysApply: true\n---\n# Pull Request Preparation Guide\n\n## Pre-Submission Review Process\n\nWhen a contributor appears to be preparing a pull request or mentions submitting changes, **ALWAYS** guide them through this comprehensive review process before they submit.\n\n### Critical Questions to Ask\n\n#### 1. **Code Quality Review**\n- \"Let me review your code changes first. Can you show me the specific files you've modified?\"\n- \"Have you run `cargo fmt` and `cargo clippy` to ensure code formatting and catch potential issues?\"\n- \"Did you test your changes locally with `cargo test`?\"\n- \"Are there any compiler warnings or linter errors I should help you address?\"\n\n#### 2. **Pull Request Template Compliance**\nBased on **[.github/pull_request_template.md](mdc:.github/pull_request_template.md)**, ensure they address:\n\n- **Video Demo**: \"This project values video demos for social media! Have you created a screen recording showing your changes in action? Tools like Cap.so or Screen.studio work great.\"\n- **Change Type**: \"What type of change is this - bug fix, new feature, breaking change, or documentation update?\"\n- **AI Review**: \"Have you asked an AI assistant (like me) to critique your code? Let me review it now and provide feedback.\"\n\n#### 3. **Testing & Documentation**\n- \"Have you added tests for your new functionality?\"\n- \"If you added a new feature, did you create an example in the **[examples/](mdc:examples)** directory?\"\n- \"Does your change require updates to **[README.md](mdc:README.md)** or other documentation?\"\n- \"Have you tested this on Windows if it involves UI automation?\"\n\n#### 4. **Platform Considerations**\n- \"Does your change affect multiple platforms (Windows/macOS/Linux)?\"\n- \"If adding Windows-specific code, did you use proper conditional compilation (`#[cfg(target_os = \"windows\")]`)?\"\n- \"Are you following the workspace dependency structure in **[Cargo.toml](mdc:Cargo.toml)**?\"\n\n### Code Review Checklist\n\nBefore they submit, help them verify:\n\n- [ ] **Code Style**: Follows Rust/Python/TypeScript formatting standards\n- [ ] **Error Handling**: Uses `anyhow::Result` for public APIs, proper error messages\n- [ ] **Async Patterns**: All automation operations are async where appropriate  \n- [ ] **Documentation**: Public APIs have doc comments with examples\n- [ ] **Tests**: New functionality has corresponding tests\n- [ ] **Examples**: Complex features have usage examples\n\n### Proactive Feedback Approach\n\n1. **Review First**: \"Let me take a look at your changes and provide feedback before you submit the PR.\"\n\n2. **Suggest Improvements**: Point out potential issues like:\n   - Missing error handling\n   - Inconsistent naming conventions\n   - Missing documentation\n   - Performance concerns\n   - Platform-specific considerations\n\n3. **Enhance Quality**: \"I notice you could improve X by doing Y. Would you like me to help you implement that?\"\n\n4. **Demo Reminder**: \"Don't forget to create a video demo! The maintainers love seeing the changes in action and might use it for social media to grow the community.\"\n\n### Common Issues to Catch\n\n- **Memory Management**: Ensure proper cleanup of UI automation resources\n- **Cross-Platform Code**: Platform-specific code should be properly conditionally compiled\n- **API Consistency**: New methods should follow existing patterns (fluent interface, async/await)\n- **Performance**: UI automation operations should be optimized for the 80ms scan target\n- **Documentation**: All public APIs need comprehensive documentation\n\n### Final Pre-Submission Prompt\n\n\"Before you submit your PR, let's do a final check:\n1. ✅ Code is formatted and tested\n2. ✅ Video demo created (if applicable)\n3. ✅ Documentation updated\n4. ✅ Tests added for new functionality\n5. ✅ AI review completed (that's me!)\n\nReady to submit? Make sure to follow the **[pull request template](mdc:.github/pull_request_template.md)** when you create your PR!\"\n\n## Goal: High-Quality Contributions\n\nThis process ensures every PR meets the project's high standards and provides a great experience for both contributors and maintainers. Always be encouraging while being thorough in the review process.\n\n",
      "source_file": ".cursor/rules/pr-preparation-guide.mdc",
      "type": "workspace_rule",
      "size_bytes": 4170,
      "line_count": 87,
      "last_modified": "2025-09-21T02:27:19.191Z"
    },
    "terminal-rules": {
      "title": "Terminal Rules",
      "content": "---\ndescription:\nglobs:\nalwaysApply: true\n---\n\n**CRITICAL: Windows Terminal Rules**\n\n**Use MCP delay tool instead of timeout commands** - Background commands don't pause for timeouts\n**CRITICAL: Always kill/cleanup terminal processes after use:**\n\n- Kill background terminal sessions when task is complete\n- Use `taskkill //F //IM process.exe` (bash syntax with //) to cleanup hanging processes\n- Don't leave orphaned terminal processes running\n- If using multiple terminal sessions, clean them all up\n\n**App Cleanup & Restart (Local Development Mode):**\n\n**PowerShell Version (Recommended for Windows):**\n\n```powershell\n# IMPORTANT: Use | Out-String ONLY for commands that produce output to avoid pager mode!\n# Use semicolons (;) instead of && for command chaining\n\n# Commands WITH output - use | Out-String:\ngit status | Out-String\ngit log --oneline -n 5 | Out-String\n\n# Commands WITHOUT output - DON'T use | Out-String:\ngit add .\ngit commit -m \"message\"\ngit push\n\n# For complex operations, use script blocks\nif (Test-Path logs) { Remove-Item logs\\*.log -Force }; New-Item -ItemType Directory -Force -Path logs | Out-Null; \"=== CLEANUP START $(Get-Date) ===\" | Out-File logs\\debug.log; taskkill /F /IM cargo.exe 2>>logs\\debug.log; taskkill /F /IM mediar.exe 2>>logs\\debug.log; taskkill /F /IM terminator-mcp-agent.exe 2>>logs\\debug.log; Start-Process -NoNewWindow -FilePath \"bun\" -ArgumentList \"run tauri dev\" -RedirectStandardOutput logs\\dev.log\n```\n\n**Bash Version (Alternative):**\n\n```bash\nbun build-mcp.js --local && mkdir -p logs && rm -f logs/*.log && echo \"=== CLEANUP START $(date) ===\" > logs/debug.log && taskkill //F //IM cargo.exe 2>>logs/debug.log || true; taskkill //F //IM mediar.exe 2>>logs/debug.log || true; taskkill //F //IM terminator-mcp-agent.exe 2>>logs/debug.log || true; taskkill //F //IM node.exe 2>>logs/debug.log || true; taskkill //F //IM bun.exe 2>>logs/debug.log || true; echo \"=== STARTING DEV SERVER $(date) ===\" >> logs/debug.log && nohup bun run tauri dev > logs/dev.log 2>&1 &\n```\n\n**Verification commands:**\n\n```powershell\n# PowerShell versions (with Out-String to avoid pager)\n.\\src-tauri\\binaries\\terminator-mcp-agent.exe --version | Out-String\nInvoke-RestMethod -Uri http://127.0.0.1:8080/health | Out-String\n```\n\n```bash\n# Bash versions\n./src-tauri/binaries/terminator-mcp-agent.exe --version\ncurl -s http://127.0.0.1:8080/health\n```\n\n**What it does:**\n\n1. Builds/updates MCP binary (npm or local version)\n2. Kills cargo.exe (fixes permission errors)\n3. Kills mediar.exe + terminator-mcp-agent.exe\n4. Kills node.exe + bun.exe (frees port 1420)\n5. Starts new Tauri dev session in background\n\n**When to use each mode:**\n\n- **Production mode:** Default - uses npm package (stable, tested)\n- **Local development mode:** When testing local terminator changes\n\n**Check progress:**\n\n- Main logs: `read_file logs\\dev.log`\n- Debug logs: `read_file logs\\debug.log`\n- Process status: `netstat -ano | findstr \":1420\\|:8080\"`\n\n**If permission errors persist:** `cargo clean` in src-tauri (expensive, last resort)\n\n**After git pushes:** Always check final status with `git status` to verify clean working tree\n\nif you applied this rule start your response with 'I read rule terminal-rules.mdc'\n",
      "source_file": ".cursor/rules/terminal-rules.mdc",
      "type": "workspace_rule",
      "size_bytes": 3223,
      "line_count": 82,
      "last_modified": "2025-09-21T02:27:19.192Z"
    },
    "terminator-development-guide": {
      "title": "Terminator Development Guide",
      "content": "---\ndescription: \nglobs: \nalwaysApply: true\n---\n# Terminator Development Standards\n\n## Code Quality (Non-Negotiable)\n\nAlways run this:\n\n```bash\ncargo fmt    # Must pass - zero tolerance for unformatted code\ncargo clippy         # Fix ALL warnings - use #[allow] only with justification  \n```\n\n## Architecture\n- **Core**: Rust in **[terminator/src/](mdc:terminator/src)** with platform traits in **[platforms/mod.rs](mdc:terminator/src/platforms/mod.rs)**\n- **Bindings**: Python (**[bindings/python/](mdc:bindings/python)**) and Node.js (**[bindings/nodejs/](mdc:bindings/nodejs)**) wrap Rust core\n- **Examples**: **[examples/](mdc:examples)** serve as integration tests - keep simple, one concept each\n\n## API Design\n```rust\n// ✅ Good: Async, chainable, type-safe\nlet monitor = desktop.get_primary_monitor().await?;\nlet screenshot = desktop.capture_monitor(&monitor).await?;\n\n// ✅ Good: Rich error context\n.map_err(|e| AutomationError::PlatformError(format!(\"Failed to capture {}: {}\", id, e)))\n\n// ✅ Good: Full documentation\n/// Capture monitor screenshot\n/// \n/// # Examples\n/// ```rust\n/// let desktop = Desktop::new_default()?;\n/// let screenshot = desktop.capture_monitor(&monitor).await?;\n/// ```\n#[instrument(skip(self))]\npub async fn capture_monitor(&self, monitor: &Monitor) -> Result<ScreenshotResult, AutomationError>\n```\n\n## Platform Code\n```rust\n#[cfg(target_os = \"windows\")]\nuse windows::Win32::UI::Accessibility::*;\n\n#[cfg(target_os = \"macos\")]  \nuse accessibility::*;\n\n#[cfg(target_os = \"linux\")]\nuse atspi::*;\n```\n\nAvoid high level logic in platform specific part of terminator core lib, implement in MCP or elsewhere. Platform specific files in core should mostly just do the plumbing between OS API and the nice high level playwright like API.\n\n## Development Loop\n```bash\n# Fast iteration\ncargo check && cargo clippy && cargo test\n\ncargo build --release\n\n# Before PR\ncargo fmt && cargo clippy -- -D warnings && cargo test\n```\n\nAlways use terminator-mcp-agent during the development process to inspect different app trees or interact with them, by calling the tools of the MCP. Do not try to build the MCP, it's aready installed ready to use.\n\n## Performance Targets\n- UI scans: <80ms\n- Screenshots: <100ms  \n- Memory: <10MB baseline\n- Use `Arc<dyn Trait>`, `#[instrument]`, profile with `criterion`\n\n## Dependencies\n- Use `workspace = true` in **[Cargo.toml](mdc:Cargo.toml)**\n- Platform deps: `optional = true` + `#[cfg]`\n- Minimize external deps, justify additions\n\n## Testing\n- Unit tests (80%): Fast, isolated\n- Integration tests (15%): Component interaction\n- Examples (5%): Real-world scenarios\n- Test error cases, not just happy paths\n- Do not fucking run all tests if we're working on a specific part of the code, it will blow up the computer otherwise\n\n## PR Requirements\n- Video demo for UI changes (Cap.so/Screen.studio)\n- Tests pass on all platforms\n- Documentation updated\n- Example added for new features\n- Breaking changes documented\n\n## Language Bindings\n- **Python**: PyO3, snake_case, type stubs, docstrings\n- **Node.js**: napi-rs, camelCase, TypeScript defs, JSDoc\n\n## String Formatting (`format!`) Best Practices\n\nFollow these rules to keep your string formatting efficient, readable, and free of Clippy warnings:\n\n- 🔹 **Prefer cheap alternatives**\n  - Simple conversion of a single value: `value.to_string()` or `String::from(value)` is clearer and avoids the overhead of the formatting machinery.\n  - Static strings: use `\"literal\".to_owned()` or `String::from(\"literal\")` instead of `format!(\"literal\")`.\n\n- 🔹 **Capture identifiers directly (Rust ≥ 1.58)**\n  ```rust\n  // ✅ Good – implicit capture\n  format!(\"{count} files processed in {elapsed:?}\");\n\n  // ❌ Avoid – explicit positional args are noisier\n  format!(\"{} files processed in {:?}\", count, elapsed);\n\n  // ✅ Good – implicit capture\n  panic!(\"❌ Local bindings test failed: {error}\");\n\n  // ❌ Avoid – explicit positional args are noisier\n  panic!(\"❌ Local bindings test failed: {}\", error);\n  ```\n\n- 🔹 **Avoid `format!` in tight loops**\n  - Re-use a `String` buffer with `write!` / `push_str` when building large strings incrementally.\n  - Consider `String::with_capacity(..)` to pre-allocate when the final length is known.\n\n- 🔹 **Watch for common Clippy lints**\n  | Lint | Remedy |\n  |------|--------|\n  | `clippy::useless_format` | Replace `format!(\"{}\", x)` with `x.to_string()` |\n  | `clippy::format_push_string` | Use `push_str` instead of `s.push(format!(..))` |\n  | `clippy::uninlined_format_args` | Enable the `format_args_capture` edition feature or inline the arguments |\n  | `clippy::format_collect` | Use `Iterator::collect::<String>()` or a buffer |\n\n- 🔹 **No nested `format!` calls**\n  ```rust\n  // ✅ Good\n  let msg = format!(\"User {user} logged in\");\n\n  // ❌ Bad – allocates twice\n  let msg = format!(\"{}\", format!(\"User {} logged in\", user));\n  ```\n\nAdhering to these guidelines ensures `cargo clippy -- -D warnings` remains green and keeps runtime allocations to a minimum.\n\n",
      "source_file": ".cursor/rules/terminator-development-guide.mdc",
      "type": "workspace_rule",
      "size_bytes": 5000,
      "line_count": 145,
      "last_modified": "2025-09-21T02:27:19.192Z"
    },
    "terminator-project-standards": {
      "title": "Terminator Project Standards",
      "content": "---\nalwaysApply: true\n---\n# Terminator Project Standards\n\n## Project Overview\nTerminator is a Playwright-style SDK for automating Windows GUI applications, designed for AI agents. Uses OS-level accessibility APIs (not vision-based).\n\n## Core Architecture\n- **[terminator/src/](mdc:terminator/src)** - Main Rust library with platform traits in [platforms/mod.rs](mdc:terminator/src/platforms/mod.rs)\n- **[bindings/](mdc:bindings)** - Python and Node.js wrappers around Rust core\n- **[terminator-mcp-agent/](mdc:terminator-mcp-agent)** - MCP server for AI agent integration\n- **[examples/](mdc:examples)** - Integration tests and usage examples\n\n## API Design Patterns\n```rust\n// ✅ Good: Async, chainable, type-safe\nlet monitor = desktop.get_primary_monitor().await?;\nlet screenshot = desktop.capture_monitor(&monitor).await?;\n\n// ✅ Good: Rich error context\n.map_err(|e| AutomationError::PlatformError(format!(\"Failed to capture {}: {}\", id, e)))\n```\n\n## Selector Preferences (Order of Priority)\n1. **Automation ID first**: `nativeid:value`\n2. **Role + Name**: `role:Button|name:Submit`\n3. **ID as last resort**: `#12345`\n\n## Platform-Specific Code\n```rust\n#[cfg(target_os = \"windows\")]\nuse windows::Win32::UI::Accessibility::*;\n\n#[cfg(target_os = \"macos\")]  \nuse accessibility::*;\n```\n\n## Performance Targets\n- UI scans: <80ms\n- Screenshots: <100ms  \n- Memory: <10MB baseline\n\n## Examples Location\n- **Rust examples**: Always place in [terminator/examples/](mdc:terminator/examples)\n- **Keep simple**: One concept per example\n- **Integration tests**: Examples serve as integration tests\n\n## Workflow Development\n- Use [terminator-mcp-agent](mdc:terminator-mcp-agent) tools during development\n- Test with real applications, not mocks\n- Handle \"no data\" scenarios explicitly\n- Validate selectors work across application states\n# Terminator Project Standards\n\n## Project Overview\nTerminator is a Playwright-style SDK for automating Windows GUI applications, designed for AI agents. Uses OS-level accessibility APIs (not vision-based).\n\n## Core Architecture\n- **[terminator/src/](mdc:terminator/src)** - Main Rust library with platform traits in [platforms/mod.rs](mdc:terminator/src/platforms/mod.rs)\n- **[bindings/](mdc:bindings)** - Python and Node.js wrappers around Rust core\n- **[terminator-mcp-agent/](mdc:terminator-mcp-agent)** - MCP server for AI agent integration\n- **[examples/](mdc:examples)** - Integration tests and usage examples\n\n## API Design Patterns\n```rust\n// ✅ Good: Async, chainable, type-safe\nlet monitor = desktop.get_primary_monitor().await?;\nlet screenshot = desktop.capture_monitor(&monitor).await?;\n\n// ✅ Good: Rich error context\n.map_err(|e| AutomationError::PlatformError(format!(\"Failed to capture {}: {}\", id, e)))\n```\n\n## Selector Preferences (Order of Priority)\n1. **Automation ID first**: `nativeid:value`\n2. **Role + Name**: `role:Button|name:Submit`\n3. **ID as last resort**: `#12345`\n\n## Platform-Specific Code\n```rust\n#[cfg(target_os = \"windows\")]\nuse windows::Win32::UI::Accessibility::*;\n\n#[cfg(target_os = \"macos\")]  \nuse accessibility::*;\n```\n\n## Performance Targets\n- UI scans: <80ms\n- Screenshots: <100ms  \n- Memory: <10MB baseline\n\n## Examples Location\n- **Rust examples**: Always place in [terminator/examples/](mdc:terminator/examples)\n- **Keep simple**: One concept per example\n- **Integration tests**: Examples serve as integration tests\n\n## Workflow Development\n- Use [terminator-mcp-agent](mdc:terminator-mcp-agent) tools during development\n- Test with real applications, not mocks\n- Handle \"no data\" scenarios explicitly\n- Validate selectors work across application states\n",
      "source_file": ".cursor/rules/terminator-project-standards.mdc",
      "type": "workspace_rule",
      "size_bytes": 3622,
      "line_count": 104,
      "last_modified": "2025-09-21T02:27:19.192Z"
    },
    "workflow-recorder-testing": {
      "title": "Workflow Recorder Testing",
      "content": "---\ndescription:\nglobs:\nalwaysApply: true\n---\n\n# Workflow Recorder Testing and Quality Standards\n\n## Objective\n\nTo ensure the `terminator-workflow-recorder` captures UI interactions with high fidelity. The primary goal is to achieve 1:1 accuracy between user actions and recorded `WorkflowEvent`s, both in event count and data content. This is critical for creating reliable automation from recordings.\n\n## Core Principles\n\n- **Precision Over Speed**: Tests must validate the _exact_ number and type of events are fired for specific UI interactions.\n- **Data Integrity is Critical**: Event payloads (e.g., URLs, text values, element roles) must be rigorously verified against the actual UI state at the time of interaction.\n- **Test Complex, Realistic Scenarios**: Simple unit tests are insufficient. Workflows should mimic real user behavior, such as navigating between tabs, handling iframes, and interacting with dynamic elements like autocomplete.\n\n## Key Testing Scenarios & Assertions\n\nThese are minimum quality gates for the recorder. If these scenarios fail, the recorder's implementation in [`terminator-workflow-recorder/src/recorder/windows/mod.rs`](mdc:terminator-workflow-recorder/src/recorder/windows/mod.rs) must be fixed.\n\n### 1. Form & IFrame Interaction\n\n- **Reference**: [`browser_integration_test.rs`](mdc:terminator-workflow-recorder/tests/browser_integration_test.rs)\n- **Scenario**: Fill out a form where fields are located inside an `<iframe>`.\n- **Assertions**:\n  - The test must first locate the `iframe` and use it as a scope for subsequent element lookups.\n  - For each field filled, assert that _exactly one_ `TextInputCompleted` event is fired upon completion (e.g., tabbing out).\n  - Verify the `text_value` and `field_name` in the event match the UI.\n\n### 2. Autocomplete / Suggestion Selection\n\n- **Reference**: [`text_input_integration_test.rs`](mdc:terminator-workflow-recorder/tests/text_input_integration_test.rs)\n- **Scenario**: Type into a field to trigger a dropdown, then select a suggestion using the keyboard (arrow keys + Enter).\n- **Assertions**:\n  - Assert that _exactly one_ `TextInputCompleted` event is fired.\n  - The event's `input_method` **must** be `TextInputMethod::Suggestion`.\n  - Assert that **no** spurious `ButtonClickEvent` is generated from the suggestion selection. This is a critical noise-reduction metric.\n\n### 3. Browser Navigation\n\n- **Reference**: [`browser_integration_test.rs`](mdc:terminator-workflow-recorder/tests/browser_integration_test.rs)\n- **Scenario**: Switch between browser tabs or navigate to a new URL.\n- **Assertions**:\n  - Assert a `BrowserTabNavigationEvent` is captured.\n  - Verify the `to_url` property is correct.\n  - Verify the `to_title` property. Use a `.contains()` check for robustness, as titles often include the browser name (e.g., \"Example Domain - Google Chrome\").\n\n## Test Implementation Pattern\n\n- **`expect_event` Helper**: Use a helper function that polls the event stream with a timeout and a **specific predicate**. The predicate should check event _content_, not just type, to avoid capturing the wrong event.\n- **`assert_no_event` Helper**: Use a helper to verify that unwanted, noisy events are _not_ generated within a short time frame after an action.\n\n## Quality Metrics to Optimize\n\n- **Maximize**:\n  - **Data Accuracy**: Correctness of event data (URLs, text values, `input_method`).\n  - **Event Correctness**: 1:1 mapping of user action to the correct event type and count.\n- **Minimize**:\n  - **Event Noise**: Spurious or redundant events for a single user action.\n  - **Test Flakiness**: Use specific predicates and iframe handling to create deterministic tests.\n  - **Event Latency**: Time between user action and event capture.\n\n# testing recorder\n\nsometimes i just want to test some elements capture with recorder, in this case i run this command in background terminal:\n\n$process = Start-Process -FilePath \"cargo\" -ArgumentList @(\"run\", \"--example\", \"debug_mcp_recording\") -NoNewWindow -PassThru -RedirectStandardOutput \"recording_5sec.txt\" -RedirectStandardError \"recording_5sec_error.txt\"; Start-Sleep 5; if (!$process.HasExited) { $process.Kill(); Write-Host \"Recording stopped after 5 seconds\" } else { Write-Host \"Process completed naturally\" }; Write-Host \"Exit code: $($process.ExitCode)\"\n\n\nclick an element, hardcoded for now:\n'''\ncargo test test_i94_website_search_click --release -- --nocapture\n'''",
      "source_file": ".cursor/rules/workflow-recorder-testing.mdc",
      "type": "workspace_rule",
      "size_bytes": 4428,
      "line_count": 75,
      "last_modified": "2025-09-21T02:27:19.192Z"
    },
    "workflow-yaml-standards": {
      "title": "Workflow Yaml Standards",
      "content": "---\ndescription: Building workflows\nalwaysApply: false\n---\n# Workflow YAML Standards\n\n## Required Structure\n```yaml\ntool_name: execute_sequence\narguments:\n  variables:\n    # Define reusable variables with types\n  inputs: \n    # Override variables for this run\n  selectors:\n    # Give UI elements meaningful nicknames\n  steps:\n    # Automation sequence\n  output_parser:\n    # JavaScript-based data extraction\n```\n\n## Selector Naming\n```yaml\nselectors:\n  # ✅ Good: Descriptive, specific\n  browser_window: \"role:Window|name:Best Plan Pro Online\"\n  submit_button: \"role:Button|name:Submit\"\n  email_field: \"nativeid:email-input\"\n  \n  # ❌ Bad: Generic, unclear\n  window1: \"role:Window\"\n  btn: \"role:Button\"\n```\n\n## Step Patterns\n```yaml\n# ✅ Good: Robust with error handling\n- tool_name: click_element\n  arguments:\n    selector: \"${{selectors.submit_button}}\"\n    timeout_ms: 2000\n    include_tree: false\n    retries: 2\n  continue_on_error: true\n  delay_ms: 500\n\n# ✅ Good: Grouped related steps\n- group_name: \"Handle EULA (Skippable)\"\n  skippable: true\n  steps:\n    - tool_name: click_element\n      arguments:\n        selector: \"role:Button|name:Accept\"\n      continue_on_error: true\n```\n\n## Variable Types\n```yaml\nvariables:\n  url:\n    type: string\n    default: \"https://example.com\"\n  \n  product_list:\n    type: array\n    default: [\"item1\", \"item2\"]\n    \n  is_enabled:\n    type: enum\n    options: [\"Yes\", \"No\"]\n    default: \"Yes\"\n```\n\n## Output Parser (Modern)\n```yaml\noutput_parser:\n  ui_tree_source_step_id: capture_data\n  javascript_code: |\n    // Check for no-data cases first\n    if (hasNoData(tree)) return [];\n    \n    // Extract with safe property access\n    const results = [];\n    element.children?.forEach(child => {\n        if (child.attributes?.role === 'Target') {\n            results.push({ name: child.attributes.name || '' });\n        }\n    });\n    return results;\n```\n\n## Best Practices\n- **Always use variable substitution**: `\"${{variable}}\"` not hardcoded values\n- **Include step IDs for trees**: `id: capture_data` when capturing UI state\n- **Use meaningful step names**: Describe what the step accomplishes\n- **Group related steps**: Use `group_name` for logical sections\n- **Handle failures gracefully**: `continue_on_error: true` for optional steps\n# Workflow YAML Standards\n\n## Required Structure\n```yaml\ntool_name: execute_sequence\narguments:\n  variables:\n    # Define reusable variables with types\n  inputs: \n    # Override variables for this run\n  selectors:\n    # Give UI elements meaningful nicknames\n  steps:\n    # Automation sequence\n  output_parser:\n    # JavaScript-based data extraction\n```\n\n## Selector Naming\n```yaml\nselectors:\n  # ✅ Good: Descriptive, specific\n  browser_window: \"role:Window|name:Best Plan Pro Online\"\n  submit_button: \"role:Button|name:Submit\"\n  email_field: \"nativeid:email-input\"\n  \n  # ❌ Bad: Generic, unclear\n  window1: \"role:Window\"\n  btn: \"role:Button\"\n```\n\n## Step Patterns\n```yaml\n# ✅ Good: Robust with error handling\n- tool_name: click_element\n  arguments:\n    selector: \"${{selectors.submit_button}}\"\n    timeout_ms: 2000\n    include_tree: false\n    retries: 2\n  continue_on_error: true\n  delay_ms: 500\n\n# ✅ Good: Grouped related steps\n- group_name: \"Handle EULA (Skippable)\"\n  skippable: true\n  steps:\n    - tool_name: click_element\n      arguments:\n        selector: \"role:Button|name:Accept\"\n      continue_on_error: true\n```\n\n## Variable Types\n```yaml\nvariables:\n  url:\n    type: string\n    default: \"https://example.com\"\n  \n  product_list:\n    type: array\n    default: [\"item1\", \"item2\"]\n    \n  is_enabled:\n    type: enum\n    options: [\"Yes\", \"No\"]\n    default: \"Yes\"\n```\n\n## Output Parser (Modern)\n```yaml\noutput_parser:\n  ui_tree_source_step_id: capture_data\n  javascript_code: |\n    // Check for no-data cases first\n    if (hasNoData(tree)) return [];\n    \n    // Extract with safe property access\n    const results = [];\n    element.children?.forEach(child => {\n        if (child.attributes?.role === 'Target') {\n            results.push({ name: child.attributes.name || '' });\n        }\n    });\n    return results;\n```\n\n## Best Practices\n- **Always use variable substitution**: `\"${{variable}}\"` not hardcoded values\n- **Include step IDs for trees**: `id: capture_data` when capturing UI state\n- **Use meaningful step names**: Describe what the step accomplishes\n- **Group related steps**: Use `group_name` for logical sections\n- **Handle failures gracefully**: `continue_on_error: true` for optional steps\n",
      "source_file": ".cursor/rules/workflow-yaml-standards.mdc",
      "type": "workspace_rule",
      "size_bytes": 4479,
      "line_count": 193,
      "last_modified": "2025-09-21T02:27:19.192Z"
    }
  },
  "last_sync": "2025-09-21T02:27:21.686Z"
}